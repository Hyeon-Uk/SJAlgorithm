문제선정기준 물어보기

2231 분해합
풀이시간: 약 15분
시간제한이 2초, 메모리제한 192MB이다. 입력값 N은 1,000,000이므로 최대 O(N*logN) 정도까지만 허용될 것 같다. 이를 염두해두고 문제를 살펴본다. 스터디에서 선정한 문제이므로 브루트포스 문제라는 것을 알고 시작했지만 문제해결방법을 모른다고 생각하고 접근했다.
 기본적으로 M+(M의 각 자리수의 합) = N(입력값)이 되는 M의 값을 구해야 한다. 문제를 모두 풀고 나서 자리수의 합을 구하는 것은 C로 여러번 구현해본 적이 있지만 더 쉬운 방법이 있을 수도 있고, 더 효율적인 방법이 있을 수도 있으니까 찾아봤다. 딱히, 추가적으로 찾아낸 방법은 없지만 지금까지 구현해왔던 방법 또한 충분히 효율적이기 때문에 앞으로도 자릿수의합을 구하는 문제를 만난다면 막힘없이 이러한 방법으로 구현할 것 같다.
 문제해결에 있어 가장 먼저 든 생각은 자연수 1부터 시작해서 최초로 위의 공식의 결과가 N이 되는 자연수를 구하는 것이었다. 이러한 방법이 브루트포스이다.
 브루트포스는 직역하자면 무차별 대입이다. 포너블을 하면서도 익히 접해본 용어이다. 알고리즘에서의 브루트포스는 가능한 모든 경우를 모두 탐색하는 방법이다. 무조건 정확한 값을 찾을 수 있는 것이 이 방법의 장점이다. 하지만 이런 장점과는 달리, 경우에 따라 알고리즘의 수행시간이 크게 증가할 수 있다는 단점도 있다. 선형구조의 탐색에선 순차탐색, 비선형구조의 탐색에서는 DFS, BFS가 있다. 
 그럼 처음 생각했던 것처럼 이 문제를 브루트포스로 풀게되면 시간복잡도는 어느정도일지 추산해봤다. 각 자연수마다 분해합을 구해야하는데, 이 과정에서 해당 숫자의 자릿수 합도 구해야 한다. 하지만 N의 범위를 고려해보면 N의 최대자릿수는 7자리이므로 이는 O(1)의 시간복잡도를 갖는다. 또 분해합은 반드시 자기자신보다 크기 때문에 반복문의 범위는 1부터 N까지인데, 이에 따라 분해합을 구하는 과정의 시간복잡도는 O(N)이다. 따라서 브루트포스로 본 문제를 풀더라도 크게 무리없을 것이라고 생각했다.

#브루트포스 #순차탐색

7568번 덩치
풀이시간: 약 10분
마찬가지로 브루트포스를 이용하는 문제이지만 문제해결방법을 모른다고 생각하며 접근했다.
입력받은 사람들의 정보들로부터 덩치의 등수를 메기는 것이 본 문제의 목적이다. 주의할 점은 등수가 같을 수도 있고, 공동등수가 여러명 있으면 해당 수만큼 뒤의 등수가 생략된다.
 메모리제한은 128MB로 입력받을 조건이 많지 않으므로 충분하다. 시간제한은 1초인데, N의 범위가 50까지이므로 대부분의 코드는 무리없이 통과할 것 같다.
 가장 먼저 든 생각은 구조체 배열로 각각의 구조체에 개인의 몸무케와 키, 덩치등수를 저장하는 것이다. 이후 구조체를 순회하며 등수를 메기는 단순한 방법으로 풀어낼 수 있다.

#브루트포스 #순차탐색

1620번 나는야 포켓몬 마스터 이다솜
풀이시작: 오전 1시 25분 ~ 오전 2시 10분, 약 35분 (문제읽는데 3분걸림)
문제오류: 2020년 3월 기준 포켓몬스터 8세대 소드실드까지의 총 포켓몬 수는 890마리이지만, 본 문제에서 입력값으로 받는 포켓몬의 수는 1보다 크거나 같고 100,000보다 작거나 같다.

피드백:
1. 문제 설계가 끝나지 않은 상태로 코딩하는 습관을 고쳐야할 것 같다.
2. 입출력을 완전히 숙지하지 못 하고 있다. cin과 cout을 공부한적 없이 C++로 알고리즘 코드를 작성해왔기 때문에 어떤 자료형을 입출력할 수 있는지 완벽하게 이해하지 못하고 있었다.
3. 2번과 마찬가지로 C++의 string클래스를 공부하지 않았기 때문에 C언어의 atoi 기능이 stoi함수로 구현되어있다거나, 다른 자료형과 동일한 방식인 cin으로 입력받는다는 것을 확실하게 알지 못 했다.

 숫자로 검색하는 것은 단순하게 배열/벡터의 인덱스로 쉽게 찾아낼 수 있을 거라 생각했기 때문에 곧바로 코딩을 했다. 하지만 코딩을 어느정도 하고나서 문자열로 검색할 때는, 정렬이 안된 벡터 내에서 탐색을 해야했다. 따라서 이 떄까지 작성한 코드로는 순차탐색밖에 불가능했다. 본 문제에서 N, M은 100,000보다 작거나 같다. 만약 N, M이 모두 100,000이고, 검색하는 입력이 모두 문자열이라면 순차탐색 코드는 O(N^2)의 어마어마한 시간복잡도를 갖게된다. 
 일반적으로 이 문제와 같이 시간제한이 2초인 경우에 입력값이 100,000이라면 최대허용가능한 시간복잡도가 O(N*logN)정도라고 예상할 수 있다. 이진탐색의 시간복잡도가 logN인 것을 고려하면 문자열로 검색하는 부분이 이진탐색으로 구현되어야만 안정적으로 문제를 해결할 수 있음을 할 수 있다. 
 하지만 앞서 얘기한 것처럼 정렬이 안된 벡터 내에서는 이진탐색이 불가능하다. 어쩔 수 없이 문자열로 검색하는 부분을 일반적인 순회를 이용해서 제출했지만 예상대로 시간초과였다. 

 따라서 이 문제를 풀기 위해서는 도감번호와 포켓몬 이름을 저장할 수 있는 구조체를 하나 정의하고, 구조체에 저장된 포켓몬 이름을 알파벳 순서로 정렬한 배열을 사용하는 것이 가장 이상적인 판단이라고 생각했다. 물론 도감번호로 탐색하는 부분은 인덱스로 접근하는 것이 가장 빠르기 때문에 이전에 사용했던 벡터는 그대로 사용한다. 그럼 추가적인 구조체 배열을 생성하여 입력은 이전과 동일하게 받고, 문자열로 검색하는 부분에서 이진탐색을 할 수 있도록 해당 배열을 정렬하면 된다. 이때, 벡터를 콜백함수로 정렬하는 방법을 찾아보고 이용했다.
 위 흐름대로 코드를 작성하고 제출했을 때, 시간초과는 아니었지만 틀렸습니다라는 문구를 봤다. 30분 가량의 삽질 끝에 오류를 찾았는데, 코딩의 편리함을 위해 N+1로 벡터를 생성했지만 이진탐색을 할 때, start 인덱스를 0, end 인덱스를 N-1로 주어 발생한 오류였다. 이 부분을 수정하고 제출하니 통과.

 난이도 상 문제로 선별한 문제인만큼 "생각보다" 문제가 어려웠다. 다른 난이도의 문제들처럼 깊이 생각하지 않고 곧바로 코딩해버리면 돌이킬 수 없을 정도로 꼬여버린다는 것을 체감했다. 물론, 입력크기와 문제요구조건에서 이진탐색을 해야한다는 것을 쉽게 파악할 수 있었기 때문에, 탐색 알고리즘을 어느정도만 알고 있더라도 쉽게 풀 수 있는 문제였던 것 같다. 이 문제를 풀며 얻은 것은 입출력, string 클래스, 콜백함수를 이용한 sort 함수 사용방법 등 부족한 지식을 어느정도 파악할 수 있었다. 마지막으로 map 자료구조를 이용한 아주 쉬운 풀이를 발견했는데 이는 STL을 추가적으로 공부하여 다시 한 번 풀어볼 예정이다.

참고
https://blockdmask.tistory.com/39
https://yyman.tistory.com/465

#이진탐색 #문자열배열정렬 #시간복잡도 #시간측정

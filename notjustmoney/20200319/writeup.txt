## 1436 영화감독 슘
* 풀이시간: 약 15분
* 키워드: 브루트포스, 알고리즘 설계

 이 문제를 고른 것은 포켓몬스터 문제를 풀 당시, 별 생각없이 코딩하게 되면 낭패를 볼 수 있다는 경험때문이었다. 분야별로 문제를 찾아보던 중, 스터디 그룹원 모두 브루트포스 문제를 풀어봤기 때문에 이 문제처럼 단순히 구현하는 문제의 경우, 설계를 조금만 하고 문제 풀기를 시작한다면 쉽게 풀 수 있을거라 생각했다.\
 간단하게 이 문제는 6이 연속으로 3개 이상 들어가는 수, 즉, 종말의 숫자 중 N번째로 작은 숫자를 구하는 문제이다. 따라서 브루트포스로 해결한다라는 생각을 배제하고 접근하더라도 가장 작은 수부터 차례로 비교해야만 구할 수 있음을 알 수 있다. 중요한 것은 시간복잡도인데 N의 범위가 10,000 이하의 자연수이므로 10,000번째 종말의 숫자까지 비교를 하게되면 몇번이나 비교해아할지 예상해봐야 한다. 이 부분은 간단하게 생각할 수 있다. 먼저 종말의 숫자인지 아닌지를 판단하는 과정은 단순히 666을 포함하고 있는지만 검사하면 되기 때문에 O(1)시간만에 수행할 수 있다. 또 천만자리의 숫자까지 종말의 숫자가 총 몇회 정도 포함되어있는지 생각해보면, 적어도 1개 이상의 종말의 숫자가 포함되어 있는 것을 알 수 있다. 따라서 N번째 종말의 숫자까지 찾는데 모든 숫자를 순회하더라도 제시된 시간제한 조건을 통과할 수 있다.\
\
 따라서 알고리즘은 다음과 같이 설계할 수 있다. 죽음의 숫자인지 아닌지 판단하는 함수를 하나 선언하고, 자연수 1부터 반복문을 돌며 죽음의 숫자의 개수를 카운트하고, N번째 카운트되는 값을 출력하면 된다. 별 차이는 없겠지만, 더 나아가 생각해본다면 자연수 666 이전까지는 죽음의 숫자가 존재하지 않기 때문에 반복문의 시작을 666으로 설정해도 무관하다.\

#브루트 포스 #알고리즘설계 

## 2805 나무자르기
* 풀이시간: 초과(60분 이상)
* 키워드: 이진탐색

 이 문제의 선정은 사실 psmaster님의 추천을 받은거나 다름없다. 알고리즘을 제대로 공부하기 시작할 때, psmaster님께서 이진탐색 문제의 예시로 지나가듯 이 문제를 얘기한적 있었는데 그 순간이 너무 빠르기도 했고, 알고리즘 문제를 풀어본 적이 별로 없어 본 문제를 제대로 이해하지 못 했었다. 어제 이진탐색 문제를 풀었기 때문에, 복습겸 이진탐색 문제를 한 문제 더 풀어보는 것도 나쁘지 않을 것 같아서 이진탐색 문제 분류에서 문제를 선정하던 중, 이 문제를 발견해 간단하게 읽어봤더니 표현만 다를 뿐, 이진탐색 문제임을 쉽게 알 수 있었다. 구현도 크게 어려울 것 같지 않아서 본 문제를 선정했다.\
 문제를 분석해보자. 시간제한은 1초, N의 범위는 1,000,000이며, 절단기 높이 H의 최댓값을 구해야한다. 조금 생각해보면, 최대 높이의 나무를 기준으로 절단기의 높이를 생각해야함을 알 수 있는데, 나무의 최대길이는 2,000,000,000이다. 엄청나게 큰 숫자인데, 만약 1부터 2,000,000,000까지 톱의 높이를 모두 검사한다면 수행시간이 적어도 1초 이상 걸릴 것이다. 따라서 더 효율적인 방법으로 H를 구해야하는데, 가장 단순한 방법으로 이진탐색을 생각해낼 수 있었다. 이진탐색은 O(logN)의 시간복잡도를 갖기 때문에, 나무 높이의 최댓값이 2,000,000,000으로 주어져도 시간제한을 무리없이 통과할 수 있다.\
 알고리즘은 다음과 같이 설계했다. 주어진 나무 길이들 중 최댓값을 찾아내어, 이 나무의 높이를 기준으로 나무 높이를 찾아낸다. 즉, 처음에는 이 최댓값의 절반으로 절단하여 가져갈 수 있는 나무 높이를 계산한다. 잘린 나무 길이가 너무 짧으면 더 아랫쪽을 자르고, 너무 길면 더 윗쪽을 자른다. 즉, 이진탐색의 방법과 동일하다.\
 실제로 코딩하여 테스트케이스를 확인해봤을 땐, 정확한 값이 나왔는데 계속 틀린 답이 나왔다. 뭘 잘못했는지 분석해봤는데, mid를 기준으로 나무를 절단했기 때문에, mid를 결과값으로 출력했다. 좀 더 생각해보자. 만약 이렇게 mid를 결과값으로 생각하게 되면 수많은 예외케이스가 발생한다. 이진탐색이 끝나기 직전 잘린 나무의 길이가 너무 길어서 start 값을 mid+1로 올린 경우에는 크게 상관없겠지만, 잘린 나무의 길이가 너무 짧아서 end값을 mid-1로 높였다면 문제가 발생한다. 이진탐색이 끝나고 바로 mid값을 출력하는데, 문제가 발생하는 경우의 mid값으로 나무를 자른다면 잘못된 결과를 출력하게 된다. 즉, 알고리즘의 설계가 잘못된 것이다. 따라서 이 부분을 수정해주면 되는데, 이전 연산에서 적합한 mid값이 나왔다면 플래그처럼 저장했다가 출력하는 방식으로 해결할 수 있었다. (코드는 추후 내용을 추가할 예정)\
 마지막으로 완벽하다 생각하여 제출했지만, 이 또한 틀린답이었다. 풀이시간이 초과되어 다른 사람들의 풀이를 봤는데 잘린 나무의 최대길이는 1,000,000,000으로 int형보다는 더 큰 자료형을 사용해야 했다. 수정하여 제출하니 통과.\

#이진탐색 #자료형

1260 DFS와 BFS
* 풀이시간: 15~20분
* 키워드: 그래프, DFS, BFS

선정기준: 그래프 자료구조와 순회, 탐색의 개념, DFS, BFS를 공부하는 취지
접근: 이 문제의 시간복잡도를 따로 생각해야 할 필요는 없음. DFS, BFS를 사용한다고 주어졌기 때문. 
설계: 각각의 함수를 구현하고, 입력값에 따른 출력만 해주면됨 

#그래프 #자료구조 #순회 #탐색 #DFS #BFS 
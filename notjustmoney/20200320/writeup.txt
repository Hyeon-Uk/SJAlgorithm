키워드 보기 기능 구현하기

15354 Aron
풀이시간: 1시 20분 ~ 1시 30분

15355 Programiranje
풀이시간: 3시 4분 ~ 3시 23분
키워드: 단순구현, DP

 이번 문제는 DP를 이용한 문제이기 때문에 DP를 먼저 공부한 문제를 풀었다. DP의 기본적인 방법만을 알고 있었기 때문에, 이번 기회에 개념을 확실하게 공부해 기본기를 다진 후, 어려운 문제도 도전해볼 계획이다.
 구글링 결과, 나무위키가 최상단에 떴는데 개념을 처음 마주할 때에는 나쁘지 않은 소스여서 해당 문서를 읽어봤다. 

 Dynamic Programming; DP
 
 특정 범위까지의 값을 구하기 위해서 그것과 다른 범위까지의 값을 이용하여 효율적으로 값을 구하는 알고리즘 설계 기법이다.(출처: 나무위키)

 역시 글로 써진 개념을 보는 것만으로는 와닿지 않는다. 더 직설적으로 설명하자면, 이전의 결과를 재활용하는 것이라고 한다. 가장 대표적인 예시이며, 지금의 내가 구현할 수 있는 가장 기본적인 코드인 피보나치 수열의 코드를 살펴보자.

 피보나치 수열은 고등수학에서도 수열 혹은 점화식을 처음 배울 때, 가장 많이 사용하는 개념이기도 하다. 기본적으로 이 수열의 n번째 항은 n-1번째 항과 n-2번째 항의 합으로 표현된다. 예를 들어, 1번째 항이 0, 2번째 항이 1인 경우, 이 수열은 다음과 같이 정의된다. 

	{0, 1, 1, 2, 3, 5, 8, 13, ... } 

 피보나치 수열의 n번째 항, 즉, n번째의 피보나치 수를 구하는 프로그램을 동적 계획법을 사용하지 않고 단순하게 구현해보자.


#include <bits/stdc++.h>
using namespace std;

long long rfibo(int n) {
	if(n == 1) return 0;
	if(n == 2) return 1;
	return rfibo(n-1)+rfibo(n-2);
}

int main() {
	int N;
	scanf("%d", &N);
	printf("%lld\n", rfibo(N));
	
	return 0;	
}

 재귀함수를 이용하면 위의 코드처럼 쉽게 구현할 수 있다. 하지만 위의 코드를 실행해 50이라는 값을 입력해보면, 마치 프로그램이 멈춘 것처럼 한참동안 아무반응이 없다가 시간이 지난 후, 엄청나게 큰 값을 출력하고 정상종료한다. 즉, 위의 코드는 비효율적이라는 것이다.
 시간복잡도를 생각해보자. n번째 피보나치 수를 구하기 위해서는 n-1번째 피보나치 수와 n-2번째 피보나치 수의 합을 구해야한다. n-1번째 피보나치 수의 합을 구하기 위해서는 n-2번째 피보나치수와 n-3번째 피보나치 수를 구해야한다. 여기까지만 살펴봐도 n번째 피보나치 수를 구하기 위해서는 n-2번째 피보나치 수를 두 번이나 중복연산한다는 것을 알 수 있다. 시간복잡도를 계산해보면 O(2^n)이 되는데, 조금이라도 입력값이 커지는 경우에는 절대 사용할 수 없는 비효율적인 결과다. 또한 재귀함수를 사용했기 때문에, 메모리 소비도 더 클 것이다. (여담이지만 모든 재귀함수는 비재귀함수로 변환할 수 있다. [참고](https://stackoverflow.com/questions/931762/can-every-recursion-be-converted-into-iteration))

 하지만 이를 동적계획법으로 설계한다면, 아주 효율적인 코드로 변환할 수 있다.

#include <bits/stdc++.h>
using namespace std;

long long m[100] = {0};
long long fibo(int n){
	if(n == 1) return 0;
	if(n == 2) return 1;
	if(m[n] != 0) {
		return m[n];	
	} else {
		m[n] = fibo(n-1) + fibo(n-2);
		return m[n];	
	}
}

int main() {
	int N;
	scanf("%d", &N);
	printf("%lld\n", fibo(N));
	return 0;	
}

 위 코드는 이전 재귀함수 코드와 유사하지만 동적계획법을 잘 보여주고 있다. 재귀함수 내부에서 n번째 피보나치 수를 반환하기 전, m이라는 배열의 n번째 인덱스에 해당 값을 저장하는 것을 볼 수 있는데, 이 과정으로 다음 번에 n번째 피보나치 수를 사용할 필요가 있을 때에는 연산없이 해당값을 바로 반환할 수 있게 된다. n번째 피보나치 수를 구하기 위해 n-2번째 피보나치 수를 구했었는데, 이 결과값을 n-1번째 피보나치 수를 구하는데 활용했다. 이처럼 어떤 문제를 풀기 위해, 그 문제를 여러 개의 하위문제로 나누어 푼 다음, 그것들을 결합하여 최종 결과에 도달하는 방법이 동적계획법이다. 지금 살펴보는 것처럼 동적계획법은 계산횟수를 획기적으로 줄여주기 때문에 하위문제 수가 기하급수적으로 증가하는 경우 아주 효율적으로 활용할 수 있다. 이 코드를 실행시켜 50을 입력한다면 별다른 지연시간 없이 바로 어떤 값이 출력되는 것을 알 수 있다. 

 참고로 예전에 동적계획법, 동적프로그래밍이라는 단어를 처음 들었을 때, 이름만 듣고서는 어떤 방법인지 도저히 알 수가 없어서 그 어원을 찾아본 적이 있었다. 동적계획법은 수학자 리처드 벨만이 고안해낸 방법인데 국내 유명 알고리즘 저서인 "프로그래밍 대회에서 배우는 알고리즘 문제해결전략"(구종만 저)에서는 이와 같은 용어를 단순히 멋때문에 사용했다고 언급된다. (그의 자서전)[https://web.archive.org/web/20180224201537/http://learning.cis.upenn.edu/cis520_fall2009/index.php?n=Notes.DP]을 읽어보면, 동적계획법은 수학연구의 결과물이었다. 그가 일했던 1950년대에는 수학 연구를 하기 좋지 못한 시기였고, 당시 리차드 벨만의 회사가 연구라는 것을 경멸하는 사람이 간부로 있던 공군의 소속이었다. 따라서 초기에는 '의사 결정 프로세스'라는 이름을 사용했지만, 프로세스라는 단어때문에 여러가지 차질이 생겨, 프로그래밍이라는 단어로 그 의미를 완화했다. 또 동적계획법의 과정이 여러 단계로 이루어져 있고, 시가변적이라는 것으로부터 '동적'이라는 단어를 선택해 이 알고리즘 방법론의 성질을 정확하게 표현할 수 있었다고 한다. 따라서 단순히 '멋'때문에 해당 용어를 사용했다는 것은 상당한 초월번역임을 알 수 있다. 프로그래밍이라는 용어가 당시 공군 내에서, 혹은 군수 물자 운송 등에 많이 사용되던 점, 2차 세계대전의 에니그마라는 큰 파장부터 애니악이 등장해 컴퓨터 관련 산업이 크게 부흥하던 점을 생각해보면 동적계획법이라는 이름이 꽤나 심사숙고하여 탄생한 이름이라는 것을 알 수 있다.
 동적계획법의 어원을 정확하게 이해했다면, 이후의 개념을 이해하거나 활용하는데에도 큰 도움이 될 것이다. 앞으로는 이 방법론이 "여러 단계"로 이루어져 있고, "시가변적"이라는 것이라는 관점에서 생각해볼 수도 있는 것이다. 

 본론으로 돌아와, 동적계획법의 개념을 정확하게 다시 한 번 짚어보자. 동적계획법은 주어진 문제를 여러개의 부분 문제로 나누어 각 부분 문제를 해결하고, 해결된 부분문제들을 활용해 원래의 문제를 해결하는 방법론이다. 즉, 어떤 부분 문제를 다른 부분 문제에서 많이 활용하면 활용할수록 계산의 속도가 향상될 수 있다.
 따라서 해결된 부분문제들을 원래 문제 해결에 활용할 때, 효율성이 높아지기 때문에, 작은 문제가 반복되는 경우에만 동적계획법을 사용할 수 있다. 또, 부분 문제를 원래 문제 해결에 사용해야 하기 때문에, 어떤 곳에 기록해두어야 한다. 이를 메모이제이션이라고 한다.

문제접근: 5만개의 글자, 최악의 경우, 5만번을 두 번 순회하며 재배열이 가능한지 확인해야함. 반드시 알파베틱 메모이제이션을 활용해야함. 부문제가 무엇인가? 경험적으로 메모이제이션을 안 것인지 직관적으로 메모이제이션을 안 것인지

12761 돌다리
풀이시간: 3시 29분 ~

DFS로 결정, BFS는 현재 루틴이 효율적인지 검사하기 힘들 것 같음.